{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Esta pr\u00e1ctica tiene como objetivo aprender a utilizar la librer\u00eda SceneKit de Apple, orientada a crear videojuegos 3D. Para ello, implementaremos un sencillo shoot'em'up en el que nuestra nave atraviesa un campo de asteroides, que deberemos esquivar y destruir. Moveremos la nave lateralmente (izquierda-derecha) utilizando el control de movimiento del dispositivo, y dispararemos haciendo tap sobre la pantalla. Podemos descargar el modelo de juego a implementar desde la App Store o ver este video del videojuego en funcionamiento. En primer lugar, crearemos un repositorio GitHub con una plantilla inicial accediendo a este enlace .","title":"Introducci\u00f3n"},{"location":"p2a.html","text":"Contamos en el proyecto con una escena de nombre ship.scn en la que vemos el modelo de nuestra nave situdada en el origen de coordenadas (0, 0, 0). Vamos a a\u00f1adir una serie de elementos a dicha escena. Skybox \u00b6 El skybox es un cubo con 6 caras mirando hacia su interior que har\u00e1 el papel del \"cielo\", permiti\u00e9ndonos girar en cualquier direcci\u00f3n. Todos los elementos de la escena 3D estar\u00e1n siempre contenidos dentro de dicho cubo, que veremos como si fuera de tama\u00f1o \"infinito\" (como si fuera el cielo). Vamos a utilizar la imagen galaxy.png como skybox de nuestra escena. TODO A01 : A\u00f1adir un skybox a la escena En el panel de la escena de ship.scn , en la propiedad Background and Lighting > Background , seleccionaremos galaxy.png , y veremos como esta imagen pasa a ser utilizada como skybox de la escena. Puedes probar a girar la escena para ver el efecto del nuevo cielo que acabamos de a\u00f1adir. Las propiedades generales de la escena podremos editarlas en el Inspector de la Escena . Luces \u00b6 Deberemos a\u00f1adir fuentes de luz para iluminar los elementos de la escena. Encontramos diferentes tipos de luces, seg\u00fan si queremos iluminar todos los objetos por igual (luz ambiente) o emitir luz desde diferentes puntos o en diferentes direcciones. Siempre ser\u00e1 conveniente contar con algo de luz ambiente para garantizar una iluminaci\u00f3n m\u00ednima, que simular\u00eda la luz general que se produce cuando la luz se refleja en todas las superficies. Vamos a continuaci\u00f3n a configurar las luces que utilizaremos en la escena. TODO A02 : A\u00f1adir dos luces a la escena: Una luz ambiente , que ilumine todas las caras por igual, con un color gris oscuro e intensidad 1000. Las propiedades de cada componente de los nodos (como lo es la luz ) podr\u00e1n ser editadas en el Inspector de Atributos . Una luz omni , que desde la posicion (0, 30, 20) ilumine en todas las direcciones por igual, de color blanco y con intensidad 2500. Para editar la posici\u00f3n de la luz deberemos utilizar el Inspector de Nodo (la posici\u00f3n es una propiedad com\u00fan de los nodos), mientras que para cambiar las propiedades espec\u00edficas de la luz utilizaremos el Inspector de Atributos . Comprueba los efectos de la luz en los elementos de la escena. Se recomienda desactivar la opci\u00f3n Default Lighting del editor (panel inferior-derecha del editor) para as\u00ed previsualizar los efectos reales de las luces que hemos a\u00f1adido. De no hacerlo, los objetos en el editor aparecer\u00e1n siempre con un iluminaci\u00f3n por defecto, aunque no hubiese puntos de luz, para as\u00ed permitirnos ver el contenido de la escena. En el juego esa iluminaci\u00f3n por defecto no se aplicar\u00e1. C\u00e1mara \u00b6 Necesitaremos a\u00f1adir una c\u00e1mara para renderizar la escena desde su punto de vista. TODO A03 : Vamos a a\u00f1adir una c\u00e1mara a la escena con las siguientes propiedades: El nombre del nodo ser\u00e1 camera . La posicionaremos en (0, 50, 20) La inclinaremos -45 grados en el eje X para que mire hacia la nave, quedando la nave en la parte inferior de la pantalla. Modificaremos el plano lejano de la c\u00e1mara ( Z Clipping > Far ) y le daremos valor 200 , para que as\u00ed se muestren objetos que est\u00e1n m\u00e1s alejados. Lo necesitaremos posteriormente para que las balas y los asteriodes que se encuentran m\u00e1s lejos se sigan viendo. Todo lo que est\u00e9 a m\u00e1s de 200 unidades de la c\u00e1mara no se renderizar\u00e1. Puedes visualizar la escena desde el punto de vista de la c\u00e1mara, para as\u00ed tener una vista previa de lo que ver\u00edamos en pantalla. Para ello seleccionamos la c\u00e1mara desde el cuadro que encontramos en la parte inferior-izquierda de la escena: En el inspector de atributos del componente c\u00e1mara, podemos ver algunas propiedades espec\u00edficas de este componente como por ejemplo Motion Blur Intensity . Por ejemplo, podr\u00edamos darle un valor de 0.8 para tener un efecto de motion blur en la escena (prueba a cambiar este valor posteriormente para ver su efecto en el juego).","title":"Escena"},{"location":"p2a.html#skybox","text":"El skybox es un cubo con 6 caras mirando hacia su interior que har\u00e1 el papel del \"cielo\", permiti\u00e9ndonos girar en cualquier direcci\u00f3n. Todos los elementos de la escena 3D estar\u00e1n siempre contenidos dentro de dicho cubo, que veremos como si fuera de tama\u00f1o \"infinito\" (como si fuera el cielo). Vamos a utilizar la imagen galaxy.png como skybox de nuestra escena. TODO A01 : A\u00f1adir un skybox a la escena En el panel de la escena de ship.scn , en la propiedad Background and Lighting > Background , seleccionaremos galaxy.png , y veremos como esta imagen pasa a ser utilizada como skybox de la escena. Puedes probar a girar la escena para ver el efecto del nuevo cielo que acabamos de a\u00f1adir. Las propiedades generales de la escena podremos editarlas en el Inspector de la Escena .","title":"Skybox"},{"location":"p2a.html#luces","text":"Deberemos a\u00f1adir fuentes de luz para iluminar los elementos de la escena. Encontramos diferentes tipos de luces, seg\u00fan si queremos iluminar todos los objetos por igual (luz ambiente) o emitir luz desde diferentes puntos o en diferentes direcciones. Siempre ser\u00e1 conveniente contar con algo de luz ambiente para garantizar una iluminaci\u00f3n m\u00ednima, que simular\u00eda la luz general que se produce cuando la luz se refleja en todas las superficies. Vamos a continuaci\u00f3n a configurar las luces que utilizaremos en la escena. TODO A02 : A\u00f1adir dos luces a la escena: Una luz ambiente , que ilumine todas las caras por igual, con un color gris oscuro e intensidad 1000. Las propiedades de cada componente de los nodos (como lo es la luz ) podr\u00e1n ser editadas en el Inspector de Atributos . Una luz omni , que desde la posicion (0, 30, 20) ilumine en todas las direcciones por igual, de color blanco y con intensidad 2500. Para editar la posici\u00f3n de la luz deberemos utilizar el Inspector de Nodo (la posici\u00f3n es una propiedad com\u00fan de los nodos), mientras que para cambiar las propiedades espec\u00edficas de la luz utilizaremos el Inspector de Atributos . Comprueba los efectos de la luz en los elementos de la escena. Se recomienda desactivar la opci\u00f3n Default Lighting del editor (panel inferior-derecha del editor) para as\u00ed previsualizar los efectos reales de las luces que hemos a\u00f1adido. De no hacerlo, los objetos en el editor aparecer\u00e1n siempre con un iluminaci\u00f3n por defecto, aunque no hubiese puntos de luz, para as\u00ed permitirnos ver el contenido de la escena. En el juego esa iluminaci\u00f3n por defecto no se aplicar\u00e1.","title":"Luces"},{"location":"p2a.html#camara","text":"Necesitaremos a\u00f1adir una c\u00e1mara para renderizar la escena desde su punto de vista. TODO A03 : Vamos a a\u00f1adir una c\u00e1mara a la escena con las siguientes propiedades: El nombre del nodo ser\u00e1 camera . La posicionaremos en (0, 50, 20) La inclinaremos -45 grados en el eje X para que mire hacia la nave, quedando la nave en la parte inferior de la pantalla. Modificaremos el plano lejano de la c\u00e1mara ( Z Clipping > Far ) y le daremos valor 200 , para que as\u00ed se muestren objetos que est\u00e1n m\u00e1s alejados. Lo necesitaremos posteriormente para que las balas y los asteriodes que se encuentran m\u00e1s lejos se sigan viendo. Todo lo que est\u00e9 a m\u00e1s de 200 unidades de la c\u00e1mara no se renderizar\u00e1. Puedes visualizar la escena desde el punto de vista de la c\u00e1mara, para as\u00ed tener una vista previa de lo que ver\u00edamos en pantalla. Para ello seleccionamos la c\u00e1mara desde el cuadro que encontramos en la parte inferior-izquierda de la escena: En el inspector de atributos del componente c\u00e1mara, podemos ver algunas propiedades espec\u00edficas de este componente como por ejemplo Motion Blur Intensity . Por ejemplo, podr\u00edamos darle un valor de 0.8 para tener un efecto de motion blur en la escena (prueba a cambiar este valor posteriormente para ver su efecto en el juego).","title":"C\u00e1mara"},{"location":"p2b.html","text":"Una vez a\u00f1adidos los componentes de la escena, vamos a poner el juego en movimiento. En este bloque veremos lo siguiente: Lectura de la entrada del usuario Tap en pantalla t\u00e1ctil (para disparar) Sensores de movimiento (para mover la nave de izquierda a derecha) Acciones ( SCNAction ) para programar el comportamiento de los disparos Ciclo del juego para mover la nave en funci\u00f3n de la inclinaci\u00f3n del m\u00f3vil Entrada del usuario \u00b6 En primer lugar vamos a realizar la lectura de la entrada del usuario. Posteriormente, utilizaremos esta entrada para mover los elementos de la escena. Tap en la pantalla t\u00e1ctil \u00b6 Para la lectura de los taps en la pantalla t\u00e1ctil, utilizaremos los componentes de UIKit orientados al reconocimiento de gestos. TODO B01 En el m\u00e9todo startTapRecognition(inView:) , crearemos un objeto de tipo UITapGestureRecognition , que cuando se produzca el evento de tap en pantalla, llame al m\u00e9todo handleTap(:) . Para ello, los gesture recognizers cuentan con el constructor init(target:action:) . Recuerda tambi\u00e9n que puedes utilizar la directiva #selector() para especificar un selector que identifique el m\u00e9todo al que queremos llamar. A\u00f1adiremos el UITapGestureRecognition a la vista (que nos llega como par\u00e1metro). Puedes ver la forma de hacer esto en la documentaci\u00f3n de UIView . Podemos ver que el m\u00e9todo handleTap(:) ya est\u00e1 implementado, y que lo \u00fanico que hace es llamar al m\u00e9todo shot() que de momento est\u00e1 vac\u00edo. En el siguiente apartado lo completaremos para implementar los disparos. Control por movimiento \u00b6 Vamos a utilizar los sensores de orientaci\u00f3n del dispositivo para implementar control por movimiento. TODO B02 En startMotionUpdates() programaremos lecturas de la orientaci\u00f3n del dispositivo ( device motion updates ) utilizando Core Motion. Utilizaremos los \u00e1ngulos pitch y roll del dispositivo para mover ligeramente la orientaci\u00f3n de la c\u00e1mara, y para cambiar la velocidad de la nave (almacenada en el campo velocity ) seg\u00fan giramos el dispositivo. Puedes utilizar el siguiente c\u00f3digo para conseguir estas funcionalidades. if ( self . motion . isDeviceMotionAvailable ) { self . motion . deviceMotionUpdateInterval = 1.0 / 60.0 self . motion . startDeviceMotionUpdates ( to : OperationQueue . main , withHandler : { ( deviceMotion , error ) -> Void in if let roll = deviceMotion ?. attitude . roll , let pitch = deviceMotion ?. attitude . pitch { self . velocity = Float ( roll ) if let cameraNode = self . cameraNode , let euler = self . cameraEulerAngle { cameraNode . eulerAngles . z = euler . z - Float ( roll ) * 0.1 cameraNode . eulerAngles . x = euler . x - Float ( pitch - 0.75 ) * 0.1 } } }) } Podemos ver que en el c\u00f3digo necesitamos acceder al nodo c\u00e1mara ( self.cameraNode ), y tambi\u00e9n necesitamos tener guardada como referencia la orientaci\u00f3n original de la c\u00e1mara ( self.cameraEulerAngle ), para hacer el giro de forma relativa a ella. TODO B03 Inicializar los campos self.cameraNode y self.cameraEulerAngle ) en el m\u00e9todo viewDidLoad() . Recuerda que en SceneKit el nodo ra\u00edz de la escena se encuentra en la propiedad rootNode de la clase SCNScene . A partir de dicho nodo ra\u00edz, podremos buscar los hijos a partir de su nombre. Una vez hecho esto, si probamos el juego veremos que la c\u00e1mara gira levemente cuando giramos el dispositivo. TODO B04 De la misma forma, tambi\u00e9n deberemos obtener el nodo con la nave ( \"ship\" ) y almacenarlo en el campo self.ship , para posteriormente poder mover la nave, o lanzar disparos desde ella. Disparos \u00b6 Vamos a implementar los disparos, y programaremos su comportamiento utilizando acciones ( SCNAction ). TODO B05 . Dentro del m\u00e9todo shot() , haremos lo siguiente: Definimos la apariencia de la bala Creamos una forma de tipo esfera ( SCNSphere ) con radio 1.0 Vamos a darle a la esfera un material que emita luz amarilla. Para ello, le asignamos en su material princpal firstMaterial , tanto en diffuse como en emission (en la propiedad contents ) el color ( UIColor ) con RGB (0.8, 0.7, 0.2). Creamos la bala como un nodo ( SCNNode ) con la geometr\u00eda de esfera anterior, d\u00e1ndole nombre \"bullet\" , y ubic\u00e1ndola en la misma posicion que la nave. A\u00f1adimos el nodo a la escena. Programamos una acci\u00f3n que haga que la bala se mueva Definimos una accion que mueva la bala 150 unidades negativas en el eje Z (durante 1 segundo), y tras ello elimine la bala de la escena. Mira la documentaci\u00f3n de SCNAction , para ver c\u00f3mo definir cada una de estas dos acciones, y c\u00f3mo encadenarlas en una secuencia. Ejecutamos la accion sobre la bala. Con esto, ya podemos probar a disparar haciendo tap en pantalla. Movimiento de la nave \u00b6 Para el movimiento de la nave, haremos que en cada iteraci\u00f3n del juego la nave se mueva seg\u00fan el valor de self.velocity (recordemos que actualizaremos esta variable en cada momento a partir del giro del dispositivo). Para ello, haremos que en el ciclo del juego la posici\u00f3n de la nave se modifique en funci\u00f3n del delta time (tiempo transcurrido desde la iteraci\u00f3n anterior) y de la velocidad actual (le\u00edda de la orientaci\u00f3n del dispositivo). Otra cuesti\u00f3n a tener en cuenta, es que para mover la nave deberemos conocer cu\u00e1les son los l\u00edmites de la pantalla, para evitar que se salga de la zona visible. Vamos a continuaci\u00f3n a abordar cada uno de estos problemas. C\u00e1lculo de los l\u00edmites visibles de la escena \u00b6 En primer lugar determinaremos cu\u00e1les son los l\u00edmites de la escena en los que podremos ubicar los objetos sin que salgan de la zona visible. Como tanto la nave, como nuestros disparos y asteroides siempre se mover\u00e1n dentro de un mismo plazo (plano XZ , es decir,en todos los casos y=0 ), nos bastar\u00e1 con definir un rect\u00e1ngulo dentro de dicho plano XZ que defina los l\u00edmites del \u00e9ste donde se desarrollar\u00e1 la acci\u00f3n. TODO B06 En el m\u00e9todo setupLimits , definiremos un CGRect con la zona de la escena 3D (dentro del plano XZ) donde se desarrollar\u00e1 la acci\u00f3n, y lo asignaremos a self.limits . La anchura del rect\u00e1ngulo corresponder\u00e1 al eje X , y la altura al eje Z . Podemos utilizar el siguiente c\u00f3digo para calcular los l\u00edmites: let projectedOrigin = view . projectPoint ( SCNVector3Zero ) let unprojectedLeft = view . unprojectPoint ( SCNVector3Make ( 0 , projectedOrigin . y , projectedOrigin . z )) let halfWidth = CGFloat ( abs ( unprojectedLeft . x )) self . limits = CGRect ( x : - halfWidth , y : - 150 , width : halfWidth * 2 , height : 200 ) Aclaraciones sobre el c\u00f3digo anterior: - Dado que la nave se situar\u00e1 en el eje X (Y=0, Z=0) , proyectamos el punto (0, 0, 0) para averiguar sus coordenadas 2D proyectadas en la pantalla. - Una vez obtenidas las coordenadas, desproyectamos las mismas coordenadas pero con X=0 (lado izquierdo de la pantalla), para obtener el punto en la escena que corresponde a ese l\u00edmite. - Al estar mirando la c\u00e1mara a (0, 0, 0) habr\u00e1 simetr\u00eda, por lo que ya sabemos la coordenada X m\u00ednima y m\u00e1xima. - El campo visual de la c\u00e1mara en la vertical por defecto es fijo. Es decir, siempre veremos el mismo contenido de la escena en la vertical independientemente del dispositivo (a no ser que lo cambiemos para hacer que la referencia sea el horizontal). De esta forma, sabemos de antemano los l\u00edmites de la escena que veremos en la coordenada Z , por lo que podemos establecerlos manualmente (de -150 a 50 ). Forma alternativa de calcular los l\u00edmites : Podr\u00edamos tambi\u00e9n utilizar los par\u00e1metros de la c\u00e1mara y el tama\u00f1o de pantalla para calcular los l\u00edmites. A partir de las dimensiones de la vista, podemos calcular su relaci\u00f3n de aspecto (ancho / alto). Conocimiendo el campo visual de la c\u00e1mara en vertical, y la relaci\u00f3n de aspecto, podr\u00edamos conocer el campo visual horizontal. Con esta informaci\u00f3n, podr\u00edamos tambi\u00e9n determinar los l\u00edmites del escenario en la horizontal y vertical. C\u00e1lculo del delta time en el ciclo del juego . \u00b6 En SceneKit , el m\u00e9todo equivalente al update que es llamado en cada iteraci\u00f3n del ciclo del juego es renderer(_:,updateAtTime:) , que se implementa en el delegado del renderer de la escena SCNSceneRendererDelegate (recordemos que en nuestro caso el renderer es la propia clase SCNView ). Para implementarlo haremos lo siguiente: TODO B07 Implementar el protocolo SCNSceneRendererDelegate en nuestra clase. TODO B08 En la inicializaci\u00f3n de la vista ( setupView ) asignaremos nuestra clase ( self ) como delegado del renderer de la escena ( view ) En nuestro renderer de la escena ( view ), activamos la propiedad isPlaying para que as\u00ed comience a reproducirse el ciclo del juego. Al activar esta propiedad se empezar\u00e1 a llamar en cada ciclo de reloj al m\u00e9todo renderer(_:,updateAtTime:) . En renderer(_:,updateAtTime:) podemos ver que nos llega el tiempo de reloj en que se realiza la actualizaci\u00f3n, pero no nos dice el tiempo transcurrido desde la iteraci\u00f3n anterior ( delta time ), esto deberemos calcularlo nosotros. En la clase hemos introducido un campo previousUpdateTime con este fin. TODO B09 En renderer(_:,updateAtTime:) calculamos el delta time , tomando como referencia el tiempo de actualizaci\u00f3n actual y el de la iteraci\u00f3n anterior. Con el siguiente c\u00f3digo, podemos conseguir que la primera vez que se llame, en la que previousUpdateTime todav\u00eda no tendr\u00e1 valor asignado, se tome el tiempo actual como referencia: let deltaTime = time - ( previousUpdateTime ?? time ) previousUpdateTime = time Movimiento de la nave \u00b6 Por \u00faltimo, a partir de la velocidad de la nave en el movimiento lateral en el eje X (obtenida a partir del giro que nos da Core Motion ) y del delta time , actualizaremos la posici\u00f3n de la nave. TODO B10 Actualizamos la posici\u00f3n X de la nave aplicando la formula posNueva = posAnterior + velocidad * tiempo . Conociendo la velocidad a la que debe ir la nave en X , y el tiempo transcurrido ( delta time ) es sencillo actualizar la posici\u00f3n. Dado que la velocidad la hemos obtenido de un valor de giro dado en radianes, estar\u00e1 en relaci\u00f3n con la inclinaci\u00f3n del m\u00f3vil, pero tendr\u00e1 un valor bastante bajo. Por ello, en la actualizaci\u00f3n de la posici\u00f3n es conveniente multiplicarla por un factor que nos permita aumentarla (por ejemplo, un factor de 200.0 puede resultar adecuado.) Una vez calculada la nueva posici\u00f3n, debemos asegurarnos de que no se salga de los l\u00edmites de la pantalla ( limits.minX y limits.maxX calculados anteriormente). En caso de salirse, corregiremos la posici\u00f3n. Para mejorar la experiencia, podemos hacer que al girar el m\u00f3vil la nave tambi\u00e9n gire hacia uno u otro lado, lo que har\u00e1 que sea m\u00e1s realista el movimiento de desplazamiento lateral. Para ello, podemos modificar el \u00e1ngulo Z ( eulerAngles ) de la nave justo en el sentido opuesto de lo que nos indica velocity (que recordemos que viene del giro del dispositivo en radianes).","title":"\u00c1cci\u00f3n"},{"location":"p2b.html#entrada-del-usuario","text":"En primer lugar vamos a realizar la lectura de la entrada del usuario. Posteriormente, utilizaremos esta entrada para mover los elementos de la escena.","title":"Entrada del usuario"},{"location":"p2b.html#tap-en-la-pantalla-tactil","text":"Para la lectura de los taps en la pantalla t\u00e1ctil, utilizaremos los componentes de UIKit orientados al reconocimiento de gestos. TODO B01 En el m\u00e9todo startTapRecognition(inView:) , crearemos un objeto de tipo UITapGestureRecognition , que cuando se produzca el evento de tap en pantalla, llame al m\u00e9todo handleTap(:) . Para ello, los gesture recognizers cuentan con el constructor init(target:action:) . Recuerda tambi\u00e9n que puedes utilizar la directiva #selector() para especificar un selector que identifique el m\u00e9todo al que queremos llamar. A\u00f1adiremos el UITapGestureRecognition a la vista (que nos llega como par\u00e1metro). Puedes ver la forma de hacer esto en la documentaci\u00f3n de UIView . Podemos ver que el m\u00e9todo handleTap(:) ya est\u00e1 implementado, y que lo \u00fanico que hace es llamar al m\u00e9todo shot() que de momento est\u00e1 vac\u00edo. En el siguiente apartado lo completaremos para implementar los disparos.","title":"Tap en la pantalla t\u00e1ctil"},{"location":"p2b.html#control-por-movimiento","text":"Vamos a utilizar los sensores de orientaci\u00f3n del dispositivo para implementar control por movimiento. TODO B02 En startMotionUpdates() programaremos lecturas de la orientaci\u00f3n del dispositivo ( device motion updates ) utilizando Core Motion. Utilizaremos los \u00e1ngulos pitch y roll del dispositivo para mover ligeramente la orientaci\u00f3n de la c\u00e1mara, y para cambiar la velocidad de la nave (almacenada en el campo velocity ) seg\u00fan giramos el dispositivo. Puedes utilizar el siguiente c\u00f3digo para conseguir estas funcionalidades. if ( self . motion . isDeviceMotionAvailable ) { self . motion . deviceMotionUpdateInterval = 1.0 / 60.0 self . motion . startDeviceMotionUpdates ( to : OperationQueue . main , withHandler : { ( deviceMotion , error ) -> Void in if let roll = deviceMotion ?. attitude . roll , let pitch = deviceMotion ?. attitude . pitch { self . velocity = Float ( roll ) if let cameraNode = self . cameraNode , let euler = self . cameraEulerAngle { cameraNode . eulerAngles . z = euler . z - Float ( roll ) * 0.1 cameraNode . eulerAngles . x = euler . x - Float ( pitch - 0.75 ) * 0.1 } } }) } Podemos ver que en el c\u00f3digo necesitamos acceder al nodo c\u00e1mara ( self.cameraNode ), y tambi\u00e9n necesitamos tener guardada como referencia la orientaci\u00f3n original de la c\u00e1mara ( self.cameraEulerAngle ), para hacer el giro de forma relativa a ella. TODO B03 Inicializar los campos self.cameraNode y self.cameraEulerAngle ) en el m\u00e9todo viewDidLoad() . Recuerda que en SceneKit el nodo ra\u00edz de la escena se encuentra en la propiedad rootNode de la clase SCNScene . A partir de dicho nodo ra\u00edz, podremos buscar los hijos a partir de su nombre. Una vez hecho esto, si probamos el juego veremos que la c\u00e1mara gira levemente cuando giramos el dispositivo. TODO B04 De la misma forma, tambi\u00e9n deberemos obtener el nodo con la nave ( \"ship\" ) y almacenarlo en el campo self.ship , para posteriormente poder mover la nave, o lanzar disparos desde ella.","title":"Control por movimiento"},{"location":"p2b.html#disparos","text":"Vamos a implementar los disparos, y programaremos su comportamiento utilizando acciones ( SCNAction ). TODO B05 . Dentro del m\u00e9todo shot() , haremos lo siguiente: Definimos la apariencia de la bala Creamos una forma de tipo esfera ( SCNSphere ) con radio 1.0 Vamos a darle a la esfera un material que emita luz amarilla. Para ello, le asignamos en su material princpal firstMaterial , tanto en diffuse como en emission (en la propiedad contents ) el color ( UIColor ) con RGB (0.8, 0.7, 0.2). Creamos la bala como un nodo ( SCNNode ) con la geometr\u00eda de esfera anterior, d\u00e1ndole nombre \"bullet\" , y ubic\u00e1ndola en la misma posicion que la nave. A\u00f1adimos el nodo a la escena. Programamos una acci\u00f3n que haga que la bala se mueva Definimos una accion que mueva la bala 150 unidades negativas en el eje Z (durante 1 segundo), y tras ello elimine la bala de la escena. Mira la documentaci\u00f3n de SCNAction , para ver c\u00f3mo definir cada una de estas dos acciones, y c\u00f3mo encadenarlas en una secuencia. Ejecutamos la accion sobre la bala. Con esto, ya podemos probar a disparar haciendo tap en pantalla.","title":"Disparos"},{"location":"p2b.html#movimiento-de-la-nave","text":"Para el movimiento de la nave, haremos que en cada iteraci\u00f3n del juego la nave se mueva seg\u00fan el valor de self.velocity (recordemos que actualizaremos esta variable en cada momento a partir del giro del dispositivo). Para ello, haremos que en el ciclo del juego la posici\u00f3n de la nave se modifique en funci\u00f3n del delta time (tiempo transcurrido desde la iteraci\u00f3n anterior) y de la velocidad actual (le\u00edda de la orientaci\u00f3n del dispositivo). Otra cuesti\u00f3n a tener en cuenta, es que para mover la nave deberemos conocer cu\u00e1les son los l\u00edmites de la pantalla, para evitar que se salga de la zona visible. Vamos a continuaci\u00f3n a abordar cada uno de estos problemas.","title":"Movimiento de la nave"},{"location":"p2b.html#calculo-de-los-limites-visibles-de-la-escena","text":"En primer lugar determinaremos cu\u00e1les son los l\u00edmites de la escena en los que podremos ubicar los objetos sin que salgan de la zona visible. Como tanto la nave, como nuestros disparos y asteroides siempre se mover\u00e1n dentro de un mismo plazo (plano XZ , es decir,en todos los casos y=0 ), nos bastar\u00e1 con definir un rect\u00e1ngulo dentro de dicho plano XZ que defina los l\u00edmites del \u00e9ste donde se desarrollar\u00e1 la acci\u00f3n. TODO B06 En el m\u00e9todo setupLimits , definiremos un CGRect con la zona de la escena 3D (dentro del plano XZ) donde se desarrollar\u00e1 la acci\u00f3n, y lo asignaremos a self.limits . La anchura del rect\u00e1ngulo corresponder\u00e1 al eje X , y la altura al eje Z . Podemos utilizar el siguiente c\u00f3digo para calcular los l\u00edmites: let projectedOrigin = view . projectPoint ( SCNVector3Zero ) let unprojectedLeft = view . unprojectPoint ( SCNVector3Make ( 0 , projectedOrigin . y , projectedOrigin . z )) let halfWidth = CGFloat ( abs ( unprojectedLeft . x )) self . limits = CGRect ( x : - halfWidth , y : - 150 , width : halfWidth * 2 , height : 200 ) Aclaraciones sobre el c\u00f3digo anterior: - Dado que la nave se situar\u00e1 en el eje X (Y=0, Z=0) , proyectamos el punto (0, 0, 0) para averiguar sus coordenadas 2D proyectadas en la pantalla. - Una vez obtenidas las coordenadas, desproyectamos las mismas coordenadas pero con X=0 (lado izquierdo de la pantalla), para obtener el punto en la escena que corresponde a ese l\u00edmite. - Al estar mirando la c\u00e1mara a (0, 0, 0) habr\u00e1 simetr\u00eda, por lo que ya sabemos la coordenada X m\u00ednima y m\u00e1xima. - El campo visual de la c\u00e1mara en la vertical por defecto es fijo. Es decir, siempre veremos el mismo contenido de la escena en la vertical independientemente del dispositivo (a no ser que lo cambiemos para hacer que la referencia sea el horizontal). De esta forma, sabemos de antemano los l\u00edmites de la escena que veremos en la coordenada Z , por lo que podemos establecerlos manualmente (de -150 a 50 ). Forma alternativa de calcular los l\u00edmites : Podr\u00edamos tambi\u00e9n utilizar los par\u00e1metros de la c\u00e1mara y el tama\u00f1o de pantalla para calcular los l\u00edmites. A partir de las dimensiones de la vista, podemos calcular su relaci\u00f3n de aspecto (ancho / alto). Conocimiendo el campo visual de la c\u00e1mara en vertical, y la relaci\u00f3n de aspecto, podr\u00edamos conocer el campo visual horizontal. Con esta informaci\u00f3n, podr\u00edamos tambi\u00e9n determinar los l\u00edmites del escenario en la horizontal y vertical.","title":"C\u00e1lculo de los l\u00edmites visibles de la escena"},{"location":"p2b.html#calculo-del-delta-time-en-el-ciclo-del-juego","text":"En SceneKit , el m\u00e9todo equivalente al update que es llamado en cada iteraci\u00f3n del ciclo del juego es renderer(_:,updateAtTime:) , que se implementa en el delegado del renderer de la escena SCNSceneRendererDelegate (recordemos que en nuestro caso el renderer es la propia clase SCNView ). Para implementarlo haremos lo siguiente: TODO B07 Implementar el protocolo SCNSceneRendererDelegate en nuestra clase. TODO B08 En la inicializaci\u00f3n de la vista ( setupView ) asignaremos nuestra clase ( self ) como delegado del renderer de la escena ( view ) En nuestro renderer de la escena ( view ), activamos la propiedad isPlaying para que as\u00ed comience a reproducirse el ciclo del juego. Al activar esta propiedad se empezar\u00e1 a llamar en cada ciclo de reloj al m\u00e9todo renderer(_:,updateAtTime:) . En renderer(_:,updateAtTime:) podemos ver que nos llega el tiempo de reloj en que se realiza la actualizaci\u00f3n, pero no nos dice el tiempo transcurrido desde la iteraci\u00f3n anterior ( delta time ), esto deberemos calcularlo nosotros. En la clase hemos introducido un campo previousUpdateTime con este fin. TODO B09 En renderer(_:,updateAtTime:) calculamos el delta time , tomando como referencia el tiempo de actualizaci\u00f3n actual y el de la iteraci\u00f3n anterior. Con el siguiente c\u00f3digo, podemos conseguir que la primera vez que se llame, en la que previousUpdateTime todav\u00eda no tendr\u00e1 valor asignado, se tome el tiempo actual como referencia: let deltaTime = time - ( previousUpdateTime ?? time ) previousUpdateTime = time","title":"C\u00e1lculo del delta time en el ciclo del juego."},{"location":"p2b.html#movimiento-de-la-nave_1","text":"Por \u00faltimo, a partir de la velocidad de la nave en el movimiento lateral en el eje X (obtenida a partir del giro que nos da Core Motion ) y del delta time , actualizaremos la posici\u00f3n de la nave. TODO B10 Actualizamos la posici\u00f3n X de la nave aplicando la formula posNueva = posAnterior + velocidad * tiempo . Conociendo la velocidad a la que debe ir la nave en X , y el tiempo transcurrido ( delta time ) es sencillo actualizar la posici\u00f3n. Dado que la velocidad la hemos obtenido de un valor de giro dado en radianes, estar\u00e1 en relaci\u00f3n con la inclinaci\u00f3n del m\u00f3vil, pero tendr\u00e1 un valor bastante bajo. Por ello, en la actualizaci\u00f3n de la posici\u00f3n es conveniente multiplicarla por un factor que nos permita aumentarla (por ejemplo, un factor de 200.0 puede resultar adecuado.) Una vez calculada la nueva posici\u00f3n, debemos asegurarnos de que no se salga de los l\u00edmites de la pantalla ( limits.minX y limits.maxX calculados anteriormente). En caso de salirse, corregiremos la posici\u00f3n. Para mejorar la experiencia, podemos hacer que al girar el m\u00f3vil la nave tambi\u00e9n gire hacia uno u otro lado, lo que har\u00e1 que sea m\u00e1s realista el movimiento de desplazamiento lateral. Para ello, podemos modificar el \u00e1ngulo Z ( eulerAngles ) de la nave justo en el sentido opuesto de lo que nos indica velocity (que recordemos que viene del giro del dispositivo en radianes).","title":"Movimiento de la nave"},{"location":"p2c.html","text":"En este apartado vamos a a\u00f1adir \"peligros\" al videojuego, e interactuar con ellos. Concretamente, estos peligros ser\u00e1n asteroides que deberemos evitar y destruir. Generaci\u00f3n de asteroides \u00b6 Vamos a tener que generar un gran n\u00famero de asteroides en la parte superior de la pantalla, en una posici\u00f3n X aleatoria, y haremos que vengan hacia nosotros. Dado que tendremos que generar m\u00faltiples asteroides \"iguales\", lo primero que haremos ser\u00e1 crear un modelo general de \"asteroide\", y lo clonaremos cada vez que queramos que aparezca un nuevo asteroide. TODO C01 En rock.scn tenemos un modelo 3D de asteroide creado, con nombre de nodo \"asteroid\" . Vamos a cargar este modelo en nuestro c\u00f3digo dentro del m\u00e9todo setupAsteroids(forView:) . Para ello podemos utilizar el siguiente c\u00f3digo: let asteroidScene = SCNScene ( named : \"art.scnassets/rock.scn\" ) self . asteroidModel = asteroidScene ?. rootNode . childNode ( withName : \"asteroid\" , recursively : false ) view . prepare ( self . asteroidModel !, shouldAbortBlock : nil ) \u00bfQu\u00e9 hace el m\u00e9todo prepare ? Consulta su documentaci\u00f3n, y prueba a ejecutar el juego llam\u00e1ndolo y sin llamarlo. \u00bfQu\u00e9 ocurre? Una vez precargado el modelo de asteroide, se llamar\u00e1 al m\u00e9todo spawnAsteroid(:) para clonar dicho modelo cada vez que queramos que aparezca ( spawn ) un asteroide nuevo (a la generaci\u00f3n de objetos y personajes en determinados puntos de la escena se le denomina spawn ). TODO C02 En el m\u00e9todo spawnAsteroid(:) , podemos generar un nuevo asteroide de la siguiente forma: if let asteroid = self . asteroidModel ?. clone () { // A\u00f1adir a la escena e inicializar propiedades del clon } Dentro de dicho bloque de c\u00f3digo deberemos: A\u00f1adir el asteroide como hijo a la escena (al mismo nodo ra\u00edz). Ubicarlo en la posici\u00f3n que nos llega como par\u00e1metro. Programar una acci\u00f3n que haga que se desplace hasta la parte inferior de los l\u00edmites ( limits ) en la misma coordenada X donde se ha generado. Hacer que al mismo tiempo el asteroide rote sobre si mismo, sobre un eje de rotaci\u00f3n aleatorio. Ayuda . Encontrar\u00e1s en el proyecto (grupo Utils ) una extensi\u00f3n de la clase SCNVector3 que te facilitar\u00e1 la generaci\u00f3n de vectores aleatorios para el eje de giro. Una vez llegue a la posici\u00f3n final, el asteroide deber\u00e1 ser eliminado de la escena (programar esto mediente la acci\u00f3n adecuada). Por \u00faltimo, nos queda utilizar el m\u00e9todo anterior para generar asteroides en la escena . Haremos que se generen en la parte superior de la pantalla, en una coordenada X aleatoria, cada cierto intervalo de tiempo. Contamos con los campos spawnInterval y timeToSpawn para controlar la periodicidad de la generaci\u00f3n de asteroides. TODO C03 En renderer(_:,updateAtTime:) descontamos el valor delta time de timeToSpawn . Cuando timeToSpawn llegue a 0, generamos un nuevo asteroide y reestablecemos el valor de timeToSpawn a spawnInterval . El asteroide debe generarse en una posicion x aleatoria entre los limites de la escena ( limits.minX y limits.maxX ), Y= 0 , y Z= limits.minY . Ayuda . Encontrar\u00e1s en el proyecto (grupo Utils ) una extensi\u00f3n de la clase Float que te facilitar\u00e1 la generaci\u00f3n de valores aleatorios. Colisiones \u00b6 Necesitamos calcular las colisiones producidas entre: - Asteroides y disparos - Asteroides y nuestra nave Definiremos las categor\u00edas de cada cuerpo f\u00edsico de la siguiente forma: let categoryMaskShip = 0b001 // (1) let categoryMaskShot = 0b010 // (2) let categoryMaskAsteroid = 0b100 // (4) TODO C04 Crea cuerpos f\u00edsicos de tipo kinematic para la nave ( ship ) dentro de ship.scn , y para el asteroide ( asteroid ) dentro de rock.scn , asignando la categor\u00eda correcta en cada caso. Puedes utilizar el panel de f\u00edsicas del editor. Ambos deben tener forma f\u00edsica ( Physics shape ) esf\u00e9rica, ajustando la escala de la esfera al tama\u00f1o del modelo aproximadamente. Ayuda . En la parte inferior-derecha de la escena vemos el desplegable Display options , dentro del cual podemos activar la opci\u00f3n Visibility > Physics , que nos permitir\u00e1 previsualizar la forma f\u00edsica de los objetos. Estos nos facilitar\u00e1 ajustar la forma f\u00edsica de forma correcta. Recomendaci\u00f3n : Es conveniente que la forma f\u00edsica para las colisiones sea algo inferior al tama\u00f1o visual de los objetos, ya que lo m\u00e1s frustrante para el jugador es que un asteoide \"mate\" a nuestra nave s\u00f3lo con \"rozarla\". TODO C05 En el m\u00e9todo shot , haz que las balas generadas tengan un cuerpo f\u00edsico con las siguientes propiedades: Tipo kinematic Forma esfera con radio 1.0 M\u00e1scara de categor\u00eda indicada anteriormente \u00bfQu\u00e9 m\u00e1scara de contacto deber\u00edan tener los asteroides en vista de las categor\u00edas de cada entidad? Asigna la m\u00e1scara de contacto correcta en el nodo asteroid dentro de rock.scn . Por \u00faltimo, necesitaremos recibir una notificaci\u00f3n de los eventos de contacto entre cuerpos, para saber cu\u00e1ndo debemos destruir un asteroide o la nave. Para ello deberemos implementar un delegado que reciba estas notificaciones. TODO C06 Implementaremos el protocolo SCNPhysicsContactDelegate en la clase TODO C07 Al final de viewDidLoad , hacemos que nuestra clase ( self ) sea el contactDelegate del mundo f\u00edsico de la escena SCNScene . TODO C08 Implementamos el m\u00e9todo physicsWorld(:, didBegin:) : func physicsWorld ( _ world : SCNPhysicsWorld , didBegin contact : SCNPhysicsContact ) { ... } Introduciremos el c\u00f3digo que haga que cuando se detecte la colisi\u00f3n de un asteroide con la nave, se llame a destroyShip(:,withAsteroid:) , y que cuando se detecta una colisi\u00f3n entre una bala y un asteroide se llame a destroyAsteroid(:,withBullet:) . A continuaci\u00f3n se sugiere una forma de organizar el c\u00f3digo para hacer esta comprobaci\u00f3n: func onContact ( asteroid : SCNNode , toNode node : SCNNode ) { if ( node . name == \"ship\" ) { destroyShip ( ship : node , withAsteroid : asteroid ) } else if ( node . name == \"bullet\" ) { destroyAsteroid ( asteroid : asteroid , withBullet : node ) } } func physicsWorld ( _ world : SCNPhysicsWorld , didBegin contact : SCNPhysicsContact ) { if ( contact . nodeA . name == \"asteroid\" ) { onContact ( asteroid : contact . nodeA , toNode : contact . nodeB ) } else if ( contact . nodeB . name == \"asteroid\" ) { onContact ( asteroid : contact . nodeB , toNode : contact . nodeA ) } } Nota . El orden en el que pueden venir los nodos que participan en el contacto es arbitrario ( nodeA y nodeB ), por ello en el c\u00f3digo anterior se han contemplado las dos posibilidades. Una vez detectados los contactos, faltar\u00eda programar sus efectos: TODO C09 En destroyAsteroid(:,withBullet:) eliminamos tanto el nodo del asteroide como el de la bala de la escena (consulta el m\u00e9todo removeFromParentNode ). TODO C10 En destroyShip(:,withAsteroid:) eliminamos el asteroide de la escena, y haz que la nave salga despedida hacia atr\u00e1s rotando (por ejemplo, que se desplace a (0, 50, 50) al mismo tiempo que rota 6.3 radianes, a lo largo de un segundo, utilizando las acciones adecuadas). Efectos de part\u00edculas \u00b6 Vamos a hacer que cuando un asteroide se destruya, se muestre un efecto de part\u00edculas como explosi\u00f3n. Contamos en el proyecto con el efecto Explode.scnp . Puedes previsualizar el efecto en el editor, y modificar sus propiedades de forma opcional. Haremos lo siguiente: TODO C11 En viewDidLoad cargamos el efecto de part\u00edculas utilizando la clase SCNParticleSystem y lo asignamos al campo explode . TODO C12 En showExplosion(onNode:) reproduciremos el efecto de part\u00edcula explode en la posici\u00f3n 3D donde estuviese el nodo que nos llegar\u00e1 por par\u00e1metro. Esto lo haremos con el m\u00e9todo addParticleSystem de SCNScene . Comprueba que al disparar sobre un asteroide se muestra la explosi\u00f3n. Marcadores \u00b6 Una forma sencilla de crear el HUD del juego (puntuaci\u00f3n, vidas restantes, etc) es superponer sobre la vista una capa definida como escena de SpriteKit. Para ello simplemente deberemos asignar un objeto de tipo SKScene a la propiedad overlaySKScene de nuestro SCNSceneRenderer (en nuestro caso el renderer ser\u00e1 la vista SCNView ). TODO C13 Configuraremos el HUD en setupHUD() , siguiendo los pasos que se indican a continuaci\u00f3n. Creamos, de forma program\u00e1tica, un SKScene en blanco con las mismas dimensiones de nuestra vista SCNView . Creamos una etiqueta SKLabelNode , inicialmente con la cadena \"0 HITS\" , con las siguientes caracter\u00edsticas: Fuente University de tama\u00f1o 36 y color naranja ( UIColor.orange ). Hacemos que la etiqueta de texto se alinee verticalmente con su parte superior (consultar las propiedades de SKLabelNode en la documentaci\u00f3n ). Situar la etiqueta en la parte superior de la pantalla, y centrada. A\u00f1ade la etiqueta como nodo hijo al HUD (a la SKScene ). Asigna la etiqueta a la propiedad marcadorAsteroides de la clase. Asigna la escena a la propiedad hud de la clase. Tal como est\u00e1 configurado hasta ahora, \u00bfqu\u00e9 ocurre con los dispositivos iPhone de serie X? Utiliza la propiedad safeAreaInsets de la vista (en nuestro caso SCNView ) para solucionar el problema. Una vez contamos con el HUD y con un marcador de puntuaci\u00f3n en \u00e9l, nos queda incrementar la puntuaci\u00f3n cada vez que destruimos un asteroide. TODO C14 En destroyAsteroid(:,withBullet:) incrementa el contador de asteroides destruidos de la clase ( numAsteroides ). A continuaci\u00f3n actualiza el marcador marcadorAsteroides con una cadena del tipo \"X HITS\" , donde X ser\u00e1 el n\u00famero de asteroides que llevamos destruidos. Comprueba que el marcador funciona correctamente. Audio \u00b6 Vamos ahora a incluir m\u00fasica de fondo y efectos de sonido en el videojuego. M\u00fasica de fondo \u00b6 La m\u00fasica sonar\u00e1 continuamente en bucle. Contamos con un fichero MP3 en el proyecto que podemos utilizar como m\u00fasica. Para ello: TODO C15 En setupAudio creamos un objeto SCNAudioSource que lea el MP3, con su propiedad loops activada, y con un volumen de 0.1. Ejecutaremos sobre el nodo raiz de la escena una acci\u00f3n de tipo SCNAction.playAudio que reproduzca la fuente de audio anterior. Con esto la m\u00fasica deber\u00e1 sonar continuamente en bucle. Efectos de sonido \u00b6 A diferencia de la m\u00fasica de fondo, los efectos de sonido es importante que se reproduzcan de forma inmediata, sin producirse ning\u00fan retraso. Por ejemplo, debemos evitar ver una explosi\u00f3n y oirla 0.5 segundos despu\u00e9s, pero la carga del sonido la primera vez producir\u00e1 siempre un peque\u00f1o retardo. Por eso es importante hacer previamente una precarga de los sonidos en el videojuego. Haremos lo siguiente: TODO C16 En setupAudio creamos un SCNAudioSource con bomb.wav y con volumen 10.0, precargamos el sonido con su m\u00e9todo load , y asignamos el sonido precargado a la propiedad soundExplosion . TODO C17 En showExplosion reproduciremos el sonido soundExplosion sobre el nodo del asteroide que ha explotado. Esto podemos hacerlo ejecutando una acci\u00f3n sobre el nodo correspondiente, pero debemos tener en cuenta que dicho nodo es eliminado de la escena justo en ese momento, por lo que la acci\u00f3n quedar\u00eda interrumpida. Soluci\u00f3n propuesta: Crea un nodo vac\u00edo en la posici\u00f3n donde estaba el asteroide que va a explorar. Reproduce el sonido mediante una acci\u00f3n sobre dicho nodo Tras completarse la acci\u00f3n de reproducci\u00f3n de sonido, ejecuta una acci\u00f3n que elimine al nodo de su padre (utiliza el mecanismo adecuado para reproducir las dos acciones en secuencia ).","title":"Enemigos"},{"location":"p2c.html#generacion-de-asteroides","text":"Vamos a tener que generar un gran n\u00famero de asteroides en la parte superior de la pantalla, en una posici\u00f3n X aleatoria, y haremos que vengan hacia nosotros. Dado que tendremos que generar m\u00faltiples asteroides \"iguales\", lo primero que haremos ser\u00e1 crear un modelo general de \"asteroide\", y lo clonaremos cada vez que queramos que aparezca un nuevo asteroide. TODO C01 En rock.scn tenemos un modelo 3D de asteroide creado, con nombre de nodo \"asteroid\" . Vamos a cargar este modelo en nuestro c\u00f3digo dentro del m\u00e9todo setupAsteroids(forView:) . Para ello podemos utilizar el siguiente c\u00f3digo: let asteroidScene = SCNScene ( named : \"art.scnassets/rock.scn\" ) self . asteroidModel = asteroidScene ?. rootNode . childNode ( withName : \"asteroid\" , recursively : false ) view . prepare ( self . asteroidModel !, shouldAbortBlock : nil ) \u00bfQu\u00e9 hace el m\u00e9todo prepare ? Consulta su documentaci\u00f3n, y prueba a ejecutar el juego llam\u00e1ndolo y sin llamarlo. \u00bfQu\u00e9 ocurre? Una vez precargado el modelo de asteroide, se llamar\u00e1 al m\u00e9todo spawnAsteroid(:) para clonar dicho modelo cada vez que queramos que aparezca ( spawn ) un asteroide nuevo (a la generaci\u00f3n de objetos y personajes en determinados puntos de la escena se le denomina spawn ). TODO C02 En el m\u00e9todo spawnAsteroid(:) , podemos generar un nuevo asteroide de la siguiente forma: if let asteroid = self . asteroidModel ?. clone () { // A\u00f1adir a la escena e inicializar propiedades del clon } Dentro de dicho bloque de c\u00f3digo deberemos: A\u00f1adir el asteroide como hijo a la escena (al mismo nodo ra\u00edz). Ubicarlo en la posici\u00f3n que nos llega como par\u00e1metro. Programar una acci\u00f3n que haga que se desplace hasta la parte inferior de los l\u00edmites ( limits ) en la misma coordenada X donde se ha generado. Hacer que al mismo tiempo el asteroide rote sobre si mismo, sobre un eje de rotaci\u00f3n aleatorio. Ayuda . Encontrar\u00e1s en el proyecto (grupo Utils ) una extensi\u00f3n de la clase SCNVector3 que te facilitar\u00e1 la generaci\u00f3n de vectores aleatorios para el eje de giro. Una vez llegue a la posici\u00f3n final, el asteroide deber\u00e1 ser eliminado de la escena (programar esto mediente la acci\u00f3n adecuada). Por \u00faltimo, nos queda utilizar el m\u00e9todo anterior para generar asteroides en la escena . Haremos que se generen en la parte superior de la pantalla, en una coordenada X aleatoria, cada cierto intervalo de tiempo. Contamos con los campos spawnInterval y timeToSpawn para controlar la periodicidad de la generaci\u00f3n de asteroides. TODO C03 En renderer(_:,updateAtTime:) descontamos el valor delta time de timeToSpawn . Cuando timeToSpawn llegue a 0, generamos un nuevo asteroide y reestablecemos el valor de timeToSpawn a spawnInterval . El asteroide debe generarse en una posicion x aleatoria entre los limites de la escena ( limits.minX y limits.maxX ), Y= 0 , y Z= limits.minY . Ayuda . Encontrar\u00e1s en el proyecto (grupo Utils ) una extensi\u00f3n de la clase Float que te facilitar\u00e1 la generaci\u00f3n de valores aleatorios.","title":"Generaci\u00f3n de asteroides"},{"location":"p2c.html#colisiones","text":"Necesitamos calcular las colisiones producidas entre: - Asteroides y disparos - Asteroides y nuestra nave Definiremos las categor\u00edas de cada cuerpo f\u00edsico de la siguiente forma: let categoryMaskShip = 0b001 // (1) let categoryMaskShot = 0b010 // (2) let categoryMaskAsteroid = 0b100 // (4) TODO C04 Crea cuerpos f\u00edsicos de tipo kinematic para la nave ( ship ) dentro de ship.scn , y para el asteroide ( asteroid ) dentro de rock.scn , asignando la categor\u00eda correcta en cada caso. Puedes utilizar el panel de f\u00edsicas del editor. Ambos deben tener forma f\u00edsica ( Physics shape ) esf\u00e9rica, ajustando la escala de la esfera al tama\u00f1o del modelo aproximadamente. Ayuda . En la parte inferior-derecha de la escena vemos el desplegable Display options , dentro del cual podemos activar la opci\u00f3n Visibility > Physics , que nos permitir\u00e1 previsualizar la forma f\u00edsica de los objetos. Estos nos facilitar\u00e1 ajustar la forma f\u00edsica de forma correcta. Recomendaci\u00f3n : Es conveniente que la forma f\u00edsica para las colisiones sea algo inferior al tama\u00f1o visual de los objetos, ya que lo m\u00e1s frustrante para el jugador es que un asteoide \"mate\" a nuestra nave s\u00f3lo con \"rozarla\". TODO C05 En el m\u00e9todo shot , haz que las balas generadas tengan un cuerpo f\u00edsico con las siguientes propiedades: Tipo kinematic Forma esfera con radio 1.0 M\u00e1scara de categor\u00eda indicada anteriormente \u00bfQu\u00e9 m\u00e1scara de contacto deber\u00edan tener los asteroides en vista de las categor\u00edas de cada entidad? Asigna la m\u00e1scara de contacto correcta en el nodo asteroid dentro de rock.scn . Por \u00faltimo, necesitaremos recibir una notificaci\u00f3n de los eventos de contacto entre cuerpos, para saber cu\u00e1ndo debemos destruir un asteroide o la nave. Para ello deberemos implementar un delegado que reciba estas notificaciones. TODO C06 Implementaremos el protocolo SCNPhysicsContactDelegate en la clase TODO C07 Al final de viewDidLoad , hacemos que nuestra clase ( self ) sea el contactDelegate del mundo f\u00edsico de la escena SCNScene . TODO C08 Implementamos el m\u00e9todo physicsWorld(:, didBegin:) : func physicsWorld ( _ world : SCNPhysicsWorld , didBegin contact : SCNPhysicsContact ) { ... } Introduciremos el c\u00f3digo que haga que cuando se detecte la colisi\u00f3n de un asteroide con la nave, se llame a destroyShip(:,withAsteroid:) , y que cuando se detecta una colisi\u00f3n entre una bala y un asteroide se llame a destroyAsteroid(:,withBullet:) . A continuaci\u00f3n se sugiere una forma de organizar el c\u00f3digo para hacer esta comprobaci\u00f3n: func onContact ( asteroid : SCNNode , toNode node : SCNNode ) { if ( node . name == \"ship\" ) { destroyShip ( ship : node , withAsteroid : asteroid ) } else if ( node . name == \"bullet\" ) { destroyAsteroid ( asteroid : asteroid , withBullet : node ) } } func physicsWorld ( _ world : SCNPhysicsWorld , didBegin contact : SCNPhysicsContact ) { if ( contact . nodeA . name == \"asteroid\" ) { onContact ( asteroid : contact . nodeA , toNode : contact . nodeB ) } else if ( contact . nodeB . name == \"asteroid\" ) { onContact ( asteroid : contact . nodeB , toNode : contact . nodeA ) } } Nota . El orden en el que pueden venir los nodos que participan en el contacto es arbitrario ( nodeA y nodeB ), por ello en el c\u00f3digo anterior se han contemplado las dos posibilidades. Una vez detectados los contactos, faltar\u00eda programar sus efectos: TODO C09 En destroyAsteroid(:,withBullet:) eliminamos tanto el nodo del asteroide como el de la bala de la escena (consulta el m\u00e9todo removeFromParentNode ). TODO C10 En destroyShip(:,withAsteroid:) eliminamos el asteroide de la escena, y haz que la nave salga despedida hacia atr\u00e1s rotando (por ejemplo, que se desplace a (0, 50, 50) al mismo tiempo que rota 6.3 radianes, a lo largo de un segundo, utilizando las acciones adecuadas).","title":"Colisiones"},{"location":"p2c.html#efectos-de-particulas","text":"Vamos a hacer que cuando un asteroide se destruya, se muestre un efecto de part\u00edculas como explosi\u00f3n. Contamos en el proyecto con el efecto Explode.scnp . Puedes previsualizar el efecto en el editor, y modificar sus propiedades de forma opcional. Haremos lo siguiente: TODO C11 En viewDidLoad cargamos el efecto de part\u00edculas utilizando la clase SCNParticleSystem y lo asignamos al campo explode . TODO C12 En showExplosion(onNode:) reproduciremos el efecto de part\u00edcula explode en la posici\u00f3n 3D donde estuviese el nodo que nos llegar\u00e1 por par\u00e1metro. Esto lo haremos con el m\u00e9todo addParticleSystem de SCNScene . Comprueba que al disparar sobre un asteroide se muestra la explosi\u00f3n.","title":"Efectos de part\u00edculas"},{"location":"p2c.html#marcadores","text":"Una forma sencilla de crear el HUD del juego (puntuaci\u00f3n, vidas restantes, etc) es superponer sobre la vista una capa definida como escena de SpriteKit. Para ello simplemente deberemos asignar un objeto de tipo SKScene a la propiedad overlaySKScene de nuestro SCNSceneRenderer (en nuestro caso el renderer ser\u00e1 la vista SCNView ). TODO C13 Configuraremos el HUD en setupHUD() , siguiendo los pasos que se indican a continuaci\u00f3n. Creamos, de forma program\u00e1tica, un SKScene en blanco con las mismas dimensiones de nuestra vista SCNView . Creamos una etiqueta SKLabelNode , inicialmente con la cadena \"0 HITS\" , con las siguientes caracter\u00edsticas: Fuente University de tama\u00f1o 36 y color naranja ( UIColor.orange ). Hacemos que la etiqueta de texto se alinee verticalmente con su parte superior (consultar las propiedades de SKLabelNode en la documentaci\u00f3n ). Situar la etiqueta en la parte superior de la pantalla, y centrada. A\u00f1ade la etiqueta como nodo hijo al HUD (a la SKScene ). Asigna la etiqueta a la propiedad marcadorAsteroides de la clase. Asigna la escena a la propiedad hud de la clase. Tal como est\u00e1 configurado hasta ahora, \u00bfqu\u00e9 ocurre con los dispositivos iPhone de serie X? Utiliza la propiedad safeAreaInsets de la vista (en nuestro caso SCNView ) para solucionar el problema. Una vez contamos con el HUD y con un marcador de puntuaci\u00f3n en \u00e9l, nos queda incrementar la puntuaci\u00f3n cada vez que destruimos un asteroide. TODO C14 En destroyAsteroid(:,withBullet:) incrementa el contador de asteroides destruidos de la clase ( numAsteroides ). A continuaci\u00f3n actualiza el marcador marcadorAsteroides con una cadena del tipo \"X HITS\" , donde X ser\u00e1 el n\u00famero de asteroides que llevamos destruidos. Comprueba que el marcador funciona correctamente.","title":"Marcadores"},{"location":"p2c.html#audio","text":"Vamos ahora a incluir m\u00fasica de fondo y efectos de sonido en el videojuego.","title":"Audio"},{"location":"p2c.html#musica-de-fondo","text":"La m\u00fasica sonar\u00e1 continuamente en bucle. Contamos con un fichero MP3 en el proyecto que podemos utilizar como m\u00fasica. Para ello: TODO C15 En setupAudio creamos un objeto SCNAudioSource que lea el MP3, con su propiedad loops activada, y con un volumen de 0.1. Ejecutaremos sobre el nodo raiz de la escena una acci\u00f3n de tipo SCNAction.playAudio que reproduzca la fuente de audio anterior. Con esto la m\u00fasica deber\u00e1 sonar continuamente en bucle.","title":"M\u00fasica de fondo"},{"location":"p2c.html#efectos-de-sonido","text":"A diferencia de la m\u00fasica de fondo, los efectos de sonido es importante que se reproduzcan de forma inmediata, sin producirse ning\u00fan retraso. Por ejemplo, debemos evitar ver una explosi\u00f3n y oirla 0.5 segundos despu\u00e9s, pero la carga del sonido la primera vez producir\u00e1 siempre un peque\u00f1o retardo. Por eso es importante hacer previamente una precarga de los sonidos en el videojuego. Haremos lo siguiente: TODO C16 En setupAudio creamos un SCNAudioSource con bomb.wav y con volumen 10.0, precargamos el sonido con su m\u00e9todo load , y asignamos el sonido precargado a la propiedad soundExplosion . TODO C17 En showExplosion reproduciremos el sonido soundExplosion sobre el nodo del asteroide que ha explotado. Esto podemos hacerlo ejecutando una acci\u00f3n sobre el nodo correspondiente, pero debemos tener en cuenta que dicho nodo es eliminado de la escena justo en ese momento, por lo que la acci\u00f3n quedar\u00eda interrumpida. Soluci\u00f3n propuesta: Crea un nodo vac\u00edo en la posici\u00f3n donde estaba el asteroide que va a explorar. Reproduce el sonido mediante una acci\u00f3n sobre dicho nodo Tras completarse la acci\u00f3n de reproducci\u00f3n de sonido, ejecuta una acci\u00f3n que elimine al nodo de su padre (utiliza el mecanismo adecuado para reproducir las dos acciones en secuencia ).","title":"Efectos de sonido"},{"location":"p2d.html","text":"Vamos a definir 4 diferentes estados en los que podr\u00e1 estar nuestro juego: Title : Muestra la pantalla de t\u00edtulo, haciendo tap sobre la pantalla pasaremos al estado Introduction Introduction : La nave aparecer\u00e1 desde la parte interior de la pantalla hasta ocupar su posici\u00f3n en el juego, pero todav\u00eda no ser\u00e1 manejable. Una vez llegue a su posici\u00f3n en la escena (0, 0, 0), se pasar\u00e1 al estado Playing . Playing : En este estado podremos manejar la nave, moviendola lateralmente o disparando. Cuando un proyectil impacte contra nosotros, pasaremos al estado GameOver GameOver : Mostrar\u00e1 la pantalla de Game Over indicando el n\u00famero de asteroides que hemos destruido durante 3 segundos, y volver\u00e1 a la pantalla de t\u00edtulo. En lugar de definir diferentes escenas para cada estado, vamos a utilizar una \u00fanica escena e implementar dentro de ella la m\u00e1quina de estados. M\u00e1quina de estados \u00b6 El videojuego se comportar\u00e1 como una m\u00e1quina de estados. Para ello haremos lo siguiente: TODO D01 Definiremos en GameViewController una enumeraci\u00f3n GameState con los estados anteriores TODO D02 Incluiremos en la clase un campo gameState de tipo GameState donde indicaremos el estado actual del juego, que inicialmente ser\u00e1 Title Seg\u00fan el estado en el que estemos, mostraremos un contenido u otro en la escena, y permitiremos realizar determinadas acciones u otra. Por ejemplo, s\u00f3lo deber\u00edan aparecer asteroides y deber\u00edamos poder manejar la nave si estamos en estado Playing . Para ello haremos las siguientes modificaciones: TODO D03 En renderer(:, updateAtTime:) s\u00f3lo generaremos asteroides y moveremos la nave si el estado actual es Playing . TODO D04 En handleTap(:) s\u00f3lo dispararemos si estamos en estado Playing . Vamos a definir ahora el contenido del resto de estados. Para simplificar la gesti\u00f3n de los estados, vamos a crear en la escena ship.scn dos nodos donde agruparemos todo el contenido a mostrar en los estados Title y GameOver , de forma que oculatando o mostrando dicho nodos podremos mostrar u ocultar todo el contenido de dichos estados. TODO D05 Crearemos en la escena ship.scn dos nodos vac\u00edos con los siguientes nombres: titleGroup gameOverGroup Dado que estos nodos b\u00e1sicamente contendr\u00e1n texto 3D frente a la c\u00e1mara, los incluiremos como hijos del nodo c\u00e1mara para que as\u00ed siempre se muestren frente a \u00e9sta, aunque la movamos de posici\u00f3n o la rotemos. Dentro del nodo c\u00e1mara, los ubicaremos en las coordenadas (0, 0, -100) , para que as\u00ed est\u00e9n 100 unidades frente a la c\u00e1mara (la c\u00e1mara por defecto mira hacia su eje Z negativo). En los siguientes apartados daremos contenido a cada uno de estos estados. Configuraci\u00f3n de la pantalla de t\u00edtulo \u00b6 Vamos a crear en el editor de la escena el contenido de la pantalla de t\u00edtulo. Mostramos a continuaci\u00f3n, a modo orientativo, un ejemplo de c\u00f3mo podr\u00eda quedar: TODO D06 En la pantalla de t\u00edtulo (dentro del nodo titleGroup ) mostraremos texto 3D con el t\u00edtulo del juego (por ejemplo Space Master 2020 ) y un texto que indique Tap to start , de forma similar a la imagen anterior Consejo : Para editar los nodos de t\u00edtulo y game over es recomendable que en el editor de la escena seleccionemos el punto de vista camera (esquina inferior-izquierda del editor de la escena). De esta forma, mientras editamos veremos lo que estar\u00eda viendo la c\u00e1mara, y por lo tanto lo que se mostrar\u00e1 en el juego. Configuraci\u00f3n de la pantalla de Game Over \u00b6 La pantalla de Game Over deber\u00e1 tener un aspecto similar al siguiente: TODO D07 En esta pantalla ( gameOverGroup ) mostraremos el texto Game Over , y adem\u00e1s otro texto que nos indique X asteroids destroyed . Esta \u00faltima cadena de texto deber\u00e1 ser identificada con el nombre gameOverResultsText que nos permita obtener una referencia a ella desde el juego. Ahora deberemos obtener referencias desde el c\u00f3digo a los nodos que acabamos de crear, para as\u00ed poder mostrarlos u ocultarlos cuando sea necesario. TODO D08 Dentro del m\u00e9todo viewDidLoad obtendremos referencias a los nodos titleGroup , gameOverGroup y GameOverResultsText . Para localizar dichos nodos, \u00bfdeberemos hacer la b\u00fasqueda recursiva? Si no queremos que la b\u00fasqueda sea recursiva, \u00bfdesde qu\u00e9 nodo deberemos buscarlos? Transiciones entre estados \u00b6 Encontramos los siguientes m\u00e9todos con los que vamos a gestionar las transiciones entre los estados del juego: startGame() : Transici\u00f3n del estado Title a Introduction , que autom\u00e1ticamente dar\u00e1 paso a Playing . showGameOver() : Transici\u00f3n del estado Playing a GameOver (cuando nos matan) showTitle() : Transici\u00f3n del estado GameOver a Title . Vamos a implementar el contenido de dichos m\u00e9todos como se indica a continuaci\u00f3n: TODO D09 Introducimos c\u00f3digo en showTitle() para hacer lo siguiente: Cambiamos el estado a Title Mostramos el nodo titleGroup (propiedad isHidden ) Ocultamos el nodo gameOverGroup Ocultamos el HUD Ocultamos la nave ( ship ) Podemos observar que al final del m\u00e9todo viewDidLoad() se llama a showTitle() , por lo que si ejecutamos el juego ahora, deber\u00e1 mostrarse la escena de t\u00edtulo inicialmente. TODO D10 Introducimos c\u00f3digo en startGame() para hacer lo siguiente: Cambiamos el estado ( gameState ) a Introduction Ocultamos titleGroup (propiedad isHidden ) Mostramos el HUD Mostramos la nave ( ship ) Ponemos a '0' el contador numAsteroides y ponemos como cadena vac\u00eda \"\" el texto de marcadorAsteroides Inicializamos la posici\u00f3n de la nave en (0, 50, 50) , tras la c\u00e1mara Ejecutamos una acci\u00f3n que mueva la nave a la posici\u00f3n (0, 0, 0) en un segundo. Una vez en dicha posici\u00f3n cambiamos el estado a Playing (puede utilizar acciones de tipo sequence , move y run , ver documentaci\u00f3n de SCNAction ). TODO D11 Vamos ahora a a\u00f1adir en handleTap(:) c\u00f3digo para que en caso de estar en estado Title , al hacer tap se llame a startGame() . De esta forma, si probamos ahora el juego veremos que ya podremos comenzar la partida haciendo tap en la escena de t\u00edtulo. TODO D12 Introducimos c\u00f3digo en showGameOver() para hacer lo siguiente: Cambiamos el estado a GameOver Ocultamos el HUD Mostramos el nodo gameOverGroup Ponemos en gameOverResultsText el texto \" X ASTEROIDS DESTROYED\", sustituyendo X por el valor correcto. Inicializamos la posici\u00f3n de gameOverGroup en (0, 0, 0) Inicializamos la opacidad de gameOverGroup a 1 (opaco) Ejecutamos una acci\u00f3n que mueva gameOverGroup a (0, 0, -200) en 2 segundos, utilizando un modificador de tiempo easeOut (ver propiedad timingMode de SCNAction ), y tras ello haga un fadeout del nodo en 0.5 segundos y llame a showTitle() para volver al titulo. TODO D13 En el m\u00e9todo destroyShip(: , withAsteroid:) llamaremos al m\u00e9todo showGameOver() , para que cuando un asteroide impacte contra nuestra nave pasemos a la pantalla de Game Over . Con esto habremos implementado todas las transiciones entre estados. Podemos probar el juego y ver c\u00f3mo realiza las transiciones entre estados: Title - Introduction - Playing - GameOver - Title .","title":"Estados"},{"location":"p2d.html#maquina-de-estados","text":"El videojuego se comportar\u00e1 como una m\u00e1quina de estados. Para ello haremos lo siguiente: TODO D01 Definiremos en GameViewController una enumeraci\u00f3n GameState con los estados anteriores TODO D02 Incluiremos en la clase un campo gameState de tipo GameState donde indicaremos el estado actual del juego, que inicialmente ser\u00e1 Title Seg\u00fan el estado en el que estemos, mostraremos un contenido u otro en la escena, y permitiremos realizar determinadas acciones u otra. Por ejemplo, s\u00f3lo deber\u00edan aparecer asteroides y deber\u00edamos poder manejar la nave si estamos en estado Playing . Para ello haremos las siguientes modificaciones: TODO D03 En renderer(:, updateAtTime:) s\u00f3lo generaremos asteroides y moveremos la nave si el estado actual es Playing . TODO D04 En handleTap(:) s\u00f3lo dispararemos si estamos en estado Playing . Vamos a definir ahora el contenido del resto de estados. Para simplificar la gesti\u00f3n de los estados, vamos a crear en la escena ship.scn dos nodos donde agruparemos todo el contenido a mostrar en los estados Title y GameOver , de forma que oculatando o mostrando dicho nodos podremos mostrar u ocultar todo el contenido de dichos estados. TODO D05 Crearemos en la escena ship.scn dos nodos vac\u00edos con los siguientes nombres: titleGroup gameOverGroup Dado que estos nodos b\u00e1sicamente contendr\u00e1n texto 3D frente a la c\u00e1mara, los incluiremos como hijos del nodo c\u00e1mara para que as\u00ed siempre se muestren frente a \u00e9sta, aunque la movamos de posici\u00f3n o la rotemos. Dentro del nodo c\u00e1mara, los ubicaremos en las coordenadas (0, 0, -100) , para que as\u00ed est\u00e9n 100 unidades frente a la c\u00e1mara (la c\u00e1mara por defecto mira hacia su eje Z negativo). En los siguientes apartados daremos contenido a cada uno de estos estados.","title":"M\u00e1quina de estados"},{"location":"p2d.html#configuracion-de-la-pantalla-de-titulo","text":"Vamos a crear en el editor de la escena el contenido de la pantalla de t\u00edtulo. Mostramos a continuaci\u00f3n, a modo orientativo, un ejemplo de c\u00f3mo podr\u00eda quedar: TODO D06 En la pantalla de t\u00edtulo (dentro del nodo titleGroup ) mostraremos texto 3D con el t\u00edtulo del juego (por ejemplo Space Master 2020 ) y un texto que indique Tap to start , de forma similar a la imagen anterior Consejo : Para editar los nodos de t\u00edtulo y game over es recomendable que en el editor de la escena seleccionemos el punto de vista camera (esquina inferior-izquierda del editor de la escena). De esta forma, mientras editamos veremos lo que estar\u00eda viendo la c\u00e1mara, y por lo tanto lo que se mostrar\u00e1 en el juego.","title":"Configuraci\u00f3n de la pantalla de t\u00edtulo"},{"location":"p2d.html#configuracion-de-la-pantalla-de-game-over","text":"La pantalla de Game Over deber\u00e1 tener un aspecto similar al siguiente: TODO D07 En esta pantalla ( gameOverGroup ) mostraremos el texto Game Over , y adem\u00e1s otro texto que nos indique X asteroids destroyed . Esta \u00faltima cadena de texto deber\u00e1 ser identificada con el nombre gameOverResultsText que nos permita obtener una referencia a ella desde el juego. Ahora deberemos obtener referencias desde el c\u00f3digo a los nodos que acabamos de crear, para as\u00ed poder mostrarlos u ocultarlos cuando sea necesario. TODO D08 Dentro del m\u00e9todo viewDidLoad obtendremos referencias a los nodos titleGroup , gameOverGroup y GameOverResultsText . Para localizar dichos nodos, \u00bfdeberemos hacer la b\u00fasqueda recursiva? Si no queremos que la b\u00fasqueda sea recursiva, \u00bfdesde qu\u00e9 nodo deberemos buscarlos?","title":"Configuraci\u00f3n de la pantalla de Game Over"},{"location":"p2d.html#transiciones-entre-estados","text":"Encontramos los siguientes m\u00e9todos con los que vamos a gestionar las transiciones entre los estados del juego: startGame() : Transici\u00f3n del estado Title a Introduction , que autom\u00e1ticamente dar\u00e1 paso a Playing . showGameOver() : Transici\u00f3n del estado Playing a GameOver (cuando nos matan) showTitle() : Transici\u00f3n del estado GameOver a Title . Vamos a implementar el contenido de dichos m\u00e9todos como se indica a continuaci\u00f3n: TODO D09 Introducimos c\u00f3digo en showTitle() para hacer lo siguiente: Cambiamos el estado a Title Mostramos el nodo titleGroup (propiedad isHidden ) Ocultamos el nodo gameOverGroup Ocultamos el HUD Ocultamos la nave ( ship ) Podemos observar que al final del m\u00e9todo viewDidLoad() se llama a showTitle() , por lo que si ejecutamos el juego ahora, deber\u00e1 mostrarse la escena de t\u00edtulo inicialmente. TODO D10 Introducimos c\u00f3digo en startGame() para hacer lo siguiente: Cambiamos el estado ( gameState ) a Introduction Ocultamos titleGroup (propiedad isHidden ) Mostramos el HUD Mostramos la nave ( ship ) Ponemos a '0' el contador numAsteroides y ponemos como cadena vac\u00eda \"\" el texto de marcadorAsteroides Inicializamos la posici\u00f3n de la nave en (0, 50, 50) , tras la c\u00e1mara Ejecutamos una acci\u00f3n que mueva la nave a la posici\u00f3n (0, 0, 0) en un segundo. Una vez en dicha posici\u00f3n cambiamos el estado a Playing (puede utilizar acciones de tipo sequence , move y run , ver documentaci\u00f3n de SCNAction ). TODO D11 Vamos ahora a a\u00f1adir en handleTap(:) c\u00f3digo para que en caso de estar en estado Title , al hacer tap se llame a startGame() . De esta forma, si probamos ahora el juego veremos que ya podremos comenzar la partida haciendo tap en la escena de t\u00edtulo. TODO D12 Introducimos c\u00f3digo en showGameOver() para hacer lo siguiente: Cambiamos el estado a GameOver Ocultamos el HUD Mostramos el nodo gameOverGroup Ponemos en gameOverResultsText el texto \" X ASTEROIDS DESTROYED\", sustituyendo X por el valor correcto. Inicializamos la posici\u00f3n de gameOverGroup en (0, 0, 0) Inicializamos la opacidad de gameOverGroup a 1 (opaco) Ejecutamos una acci\u00f3n que mueva gameOverGroup a (0, 0, -200) en 2 segundos, utilizando un modificador de tiempo easeOut (ver propiedad timingMode de SCNAction ), y tras ello haga un fadeout del nodo en 0.5 segundos y llame a showTitle() para volver al titulo. TODO D13 En el m\u00e9todo destroyShip(: , withAsteroid:) llamaremos al m\u00e9todo showGameOver() , para que cuando un asteroide impacte contra nuestra nave pasemos a la pantalla de Game Over . Con esto habremos implementado todas las transiciones entre estados. Podemos probar el juego y ver c\u00f3mo realiza las transiciones entre estados: Title - Introduction - Playing - GameOver - Title .","title":"Transiciones entre estados"}]}